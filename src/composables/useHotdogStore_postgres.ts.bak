import { ref, computed } from 'vue'
import {
  supabase,
  type ToppingOption,
  type HotdogEntryWithToppings,
} from '../lib/supabase'

// ãƒˆãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ—ã‚·ãƒ§ãƒ³
export const toppingOptions = ref<ToppingOption[]>([])

// ãƒ›ãƒƒãƒˆãƒ‰ãƒƒã‚°ã‚¨ãƒ³ãƒˆãƒªãƒ¼
export const entries = ref<HotdogEntryWithToppings[]>([])

// ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹
export const loading = ref(false)
export const error = ref<string | null>(null)

// LocalStorage ã®ã‚­ãƒ¼ï¼ˆãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
const STORAGE_KEY = 'recorder.hotdogs.v2'
const OLD_STORAGE_KEY = 'recorder.hotdogs.v1'

// åˆæœŸåŒ–: ãƒˆãƒƒãƒ”ãƒ³ã‚°ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’å–å¾—
export async function initializeStore() {
  loading.value = true
  error.value = null

  try {
    const { data, error: fetchError } = await supabase
      .from('topping_options')
      .select('*')
      .order('display_order', { ascending: true })

    if (fetchError) throw fetchError

    toppingOptions.value = data || []
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼'
    console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã®å–å¾—ï¼ˆãƒˆãƒƒãƒ”ãƒ³ã‚°æƒ…å ±ã‚‚çµåˆï¼‰
export async function fetchEntries() {
  loading.value = true
  error.value = null

  try {
    // 1å›ã®ã‚¯ã‚¨ãƒªã§å…¨ã¦ã‚’å–å¾—ï¼ˆJOINä½¿ç”¨ï¼‰
    const { data: entriesData, error: entriesError } = await supabase
      .from('hotdog_entries')
      .select(`
        *,
        entry_toppings (
          topping_options (*)
        )
      `)
      .order('created_at', { ascending: true })

    if (entriesError) throw entriesError

    // ãƒ‡ãƒ¼ã‚¿ã‚’æ•´å½¢
    const entriesWithToppings: HotdogEntryWithToppings[] = (entriesData || []).map((entry: any) => {
      const toppings: ToppingOption[] = (entry.entry_toppings || [])
        .map((et: any) => et.topping_options)
        .filter(Boolean)
        .sort((a: ToppingOption, b: ToppingOption) => a.display_order - b.display_order)

      return {
        id: entry.id,
        created_at: entry.created_at,
        completed: entry.completed,
        completed_at: entry.completed_at,
        user_id: entry.user_id,
        toppings,
      }
    })

    entries.value = entriesWithToppings
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼'
    console.error('ã‚¨ãƒ³ãƒˆãƒªãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã®è¿½åŠ 
export async function addEntry(toppingIds: string[]) {
  loading.value = true
  error.value = null

  try {
    // 1. ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’ä½œæˆ
    const { data: newEntry, error: entryError } = await supabase
      .from('hotdog_entries')
      .insert({
        completed: false,
        completed_at: null,
      })
      .select()
      .single()

    if (entryError) throw entryError

    // 2. ãƒˆãƒƒãƒ”ãƒ³ã‚°ã‚’é–¢é€£ä»˜ã‘
    if (toppingIds.length > 0) {
      const entryToppings = toppingIds.map((toppingId) => ({
        entry_id: newEntry.id,
        topping_id: toppingId,
      }))

      const { error: toppingsError } = await supabase
        .from('entry_toppings')
        .insert(entryToppings)

      if (toppingsError) throw toppingsError
    }

    // å³åº§ã«å†å–å¾—ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚ˆã‚Šé€Ÿã„ï¼‰
    await fetchEntries()
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼è¿½åŠ ã‚¨ãƒ©ãƒ¼'
    console.error('ã‚¨ãƒ³ãƒˆãƒªãƒ¼è¿½åŠ ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã®å‰Šé™¤
export async function deleteEntry(id: string) {
  loading.value = true
  error.value = null

  try {
    const { error: deleteError } = await supabase
      .from('hotdog_entries')
      .delete()
      .eq('id', id)

    if (deleteError) throw deleteError

    // å³åº§ã«å†å–å¾—
    await fetchEntries()
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼å‰Šé™¤ã‚¨ãƒ©ãƒ¼'
    console.error('ã‚¨ãƒ³ãƒˆãƒªãƒ¼å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã®å®Œäº†
export async function completeEntry(id: string) {
  loading.value = true
  error.value = null

  try {
    const { error: updateError } = await supabase
      .from('hotdog_entries')
      .update({
        completed: true,
        completed_at: new Date().toISOString(),
      })
      .eq('id', id)

    if (updateError) throw updateError

    // å³åº§ã«å†å–å¾—
    await fetchEntries()
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼å®Œäº†ã‚¨ãƒ©ãƒ¼'
    console.error('ã‚¨ãƒ³ãƒˆãƒªãƒ¼å®Œäº†ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã®æœªå®Œäº†åŒ–
export async function uncompleteEntry(id: string) {
  loading.value = true
  error.value = null

  try {
    const { error: updateError } = await supabase
      .from('hotdog_entries')
      .update({
        completed: false,
        completed_at: null,
      })
      .eq('id', id)

    if (updateError) throw updateError

    // å³åº§ã«å†å–å¾—
    await fetchEntries()
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼æœªå®Œäº†åŒ–ã‚¨ãƒ©ãƒ¼'
    console.error('ã‚¨ãƒ³ãƒˆãƒªãƒ¼æœªå®Œäº†åŒ–ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// å…¨ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤
export async function clearAllData() {
  loading.value = true
  error.value = null

  try {
    const { error: deleteError } = await supabase
      .from('hotdog_entries')
      .delete()
      .neq('id', '00000000-0000-0000-0000-000000000000') // å…¨ä»¶å‰Šé™¤

    if (deleteError) throw deleteError

    entries.value = []
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'å…¨å‰Šé™¤ã‚¨ãƒ©ãƒ¼'
    console.error('å…¨å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// ã‚«ã‚¹ã‚¿ãƒ ãƒˆãƒƒãƒ”ãƒ³ã‚°ã®è¿½åŠ 
export async function addCustomTopping(name: string, emoji: string) {
  loading.value = true
  error.value = null

  try {
    // æœ€å¤§ã®display_orderã‚’å–å¾—
    const { data: maxOrderData, error: maxOrderError } = await supabase
      .from('topping_options')
      .select('display_order')
      .order('display_order', { ascending: false })
      .limit(1)
      .single()

    if (maxOrderError && maxOrderError.code !== 'PGRST116') {
      // PGRST116 = no rows returned
      throw maxOrderError
    }

    const nextOrder = maxOrderData ? maxOrderData.display_order + 1 : 1

    // æ–°ã—ã„ãƒˆãƒƒãƒ”ãƒ³ã‚°ã‚’è¿½åŠ 
    const { data: newTopping, error: insertError } = await supabase
      .from('topping_options')
      .insert({
        name,
        emoji,
        display_order: nextOrder,
      })
      .select()
      .single()

    if (insertError) throw insertError

    // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã«è¿½åŠ ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°å¾…ãŸãšã«ã™ãåæ˜ ï¼‰
    if (newTopping) {
      toppingOptions.value.push(newTopping)
    }
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'ãƒˆãƒƒãƒ”ãƒ³ã‚°è¿½åŠ ã‚¨ãƒ©ãƒ¼'
    console.error('ãƒˆãƒƒãƒ”ãƒ³ã‚°è¿½åŠ ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// ===== Computed Properties =====

// ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã‚¨ãƒ³ãƒˆãƒªãƒ¼ï¼ˆå®Œäº†æ¸ˆã¿ãŒä¸Šã€æœªå®Œäº†ãŒä¸‹ã€ãã‚Œãã‚Œå¤ã„é †ï¼‰
export const sortedEntries = computed(() => {
  return [...entries.value].sort((a, b) => {
    // æœªå®Œäº†ã‚’ä¸‹ã«ï¼ˆå®Œäº†æ¸ˆã¿ãŒä¸Šï¼‰
    if (a.completed !== b.completed) {
      return a.completed ? -1 : 1
    }
    // åŒã˜å®Œäº†çŠ¶æ…‹å†…ã§ã¯å¤ã„é †ï¼ˆcreated_at æ˜‡é †ï¼‰
    return new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
  })
})

// åˆè¨ˆãƒ›ãƒƒãƒˆãƒ‰ãƒƒã‚°æ•°
export const totalHotdogs = computed(() => entries.value.length)

// ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒˆãƒƒãƒ”ãƒ³ã‚°æ•°
export const uniqueToppingsUsed = computed(() => {
  const bag = new Set<string>()
  entries.value.forEach((entry) => {
    entry.toppings.forEach((topping) => {
      bag.add(`${topping.emoji} ${topping.name}`)
    })
  })
  return bag.size
})

// ãƒˆãƒƒãƒ”ãƒ³ã‚°ã®å‡ºç¾é »åº¦
export const toppingFrequency = computed(() => {
  const frequency: Record<string, number> = {}

  entries.value.forEach((entry) => {
    if (entry.toppings.length === 0) {
      frequency['ğŸŒ­ ãƒãƒ¼ãƒãƒ«'] = (frequency['ğŸŒ­ ãƒãƒ¼ãƒãƒ«'] || 0) + 1
    } else {
      entry.toppings.forEach((topping) => {
        const key = `${topping.emoji} ${topping.name}`
        frequency[key] = (frequency[key] || 0) + 1
      })
    }
  })

  return Object.entries(frequency)
    .sort((a, b) => b[1] - a[1])
    .map(([name, count]) => ({ name, count }))
})

// ãƒˆãƒƒãƒ—3ãƒˆãƒƒãƒ”ãƒ³ã‚°
export const topToppings = computed(() => toppingFrequency.value.slice(0, 3))

// æ™‚é–“ã”ã¨ã®å£²ä¸Šï¼ˆ24æ™‚é–“ï¼‰
export const hourlySales = computed(() => {
  const hourCounts = new Map<number, number>()
  entries.value.forEach((entry) => {
    const date = new Date(entry.created_at)
    const hour = date.getHours()
    hourCounts.set(hour, (hourCounts.get(hour) ?? 0) + 1)
  })

  // Create array with all 24 hours, filling in zeros for hours with no sales
  const result: Array<{ hour: number; count: number }> = []
  for (let hour = 0; hour < 24; hour++) {
    result.push({
      hour,
      count: hourCounts.get(hour) ?? 0,
    })
  }
  return result
})

// ===== Real-time Subscriptions =====

// ãƒ‡ãƒã‚¦ãƒ³ã‚¹ç”¨ã‚¿ã‚¤ãƒãƒ¼
let fetchDebounceTimer: ReturnType<typeof setTimeout> | null = null

// ãƒ‡ãƒã‚¦ãƒ³ã‚¹ä»˜ãå†å–å¾—
function debouncedFetchEntries() {
  if (fetchDebounceTimer) {
    clearTimeout(fetchDebounceTimer)
  }
  fetchDebounceTimer = setTimeout(() => {
    fetchEntries()
    fetchDebounceTimer = null
  }, 300) // 300mså¾…ã£ã¦ã‹ã‚‰å®Ÿè¡Œ
}

// ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã®è³¼èª­ï¼ˆãƒãƒ¼ãƒªãƒ³ã‚°æ–¹å¼ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯èƒ½ï¼‰
export function subscribeToEntries() {
  console.log('ğŸ”µ Realtime: æ¥ç¶šè©¦è¡Œä¸­...')
  
  const channel = supabase
    .channel('hotdog_entries_changes', {
      config: {
        broadcast: { self: true },
      },
    })
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'hotdog_entries',
      },
      (payload) => {
        console.log('ğŸŸ¢ hotdog_entries å¤‰æ›´æ¤œçŸ¥:', payload)
        debouncedFetchEntries()
      }
    )
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'entry_toppings',
      },
      (payload) => {
        console.log('ğŸŸ¢ entry_toppings å¤‰æ›´æ¤œçŸ¥:', payload)
        debouncedFetchEntries()
      }
    )
    .subscribe((status) => {
      if (status === 'SUBSCRIBED') {
        console.log('âœ… Realtime: æ¥ç¶šæˆåŠŸ (postgres_changes)')
      } else if (status === 'CHANNEL_ERROR') {
        console.error('âŒ Realtime: æ¥ç¶šã‚¨ãƒ©ãƒ¼ - ãƒãƒ¼ãƒªãƒ³ã‚°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯')
        // Realtime ãŒä½¿ãˆãªã„å ´åˆã¯ãƒãƒ¼ãƒªãƒ³ã‚°ã§ä»£æ›¿
        startPolling()
      } else if (status === 'TIMED_OUT') {
        console.error('â±ï¸ Realtime: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - ãƒãƒ¼ãƒªãƒ³ã‚°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯')
        startPolling()
      } else {
        console.log('ğŸ”µ Realtime ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:', status)
      }
    })

  return channel
}

// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®ãƒãƒ¼ãƒªãƒ³ã‚°ï¼ˆ10ç§’é–“éš”ï¼‰
let pollingInterval: number | null = null

function startPolling() {
  if (pollingInterval) return // æ—¢ã«é–‹å§‹æ¸ˆã¿
  
  console.log('ğŸ”„ ãƒãƒ¼ãƒªãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰é–‹å§‹ï¼ˆ10ç§’é–“éš”ï¼‰')
  pollingInterval = window.setInterval(() => {
    console.log('ğŸ”„ ãƒ‡ãƒ¼ã‚¿æ›´æ–°ãƒã‚§ãƒƒã‚¯...')
    fetchEntries()
  }, 10000) // 10ç§’ã”ã¨
}

export function stopPolling() {
  if (pollingInterval) {
    clearInterval(pollingInterval)
    pollingInterval = null
    console.log('â¹ï¸ ãƒãƒ¼ãƒªãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰åœæ­¢')
  }
}

// LocalStorage ã‹ã‚‰ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆåˆå›ã®ã¿ï¼‰
export async function migrateFromLocalStorage() {
  const v2Data = localStorage.getItem(STORAGE_KEY)
  const v1Data = localStorage.getItem(OLD_STORAGE_KEY)

  if (!v2Data && !v1Data) {
    return // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸è¦
  }

  loading.value = true
  error.value = null

  try {
    let localEntries: any[] = []

    if (v2Data) {
      const parsed = JSON.parse(v2Data)
      localEntries = parsed.entries || []
    } else if (v1Data) {
      const v1Entries = JSON.parse(v1Data)
      localEntries = v1Entries.map((entry: any) => ({
        ...entry,
        completed: true,
        completedAt: entry.createdAt,
      }))
    }

    // Supabase ã«ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    for (const localEntry of localEntries) {
      // ãƒˆãƒƒãƒ”ãƒ³ã‚°åã‹ã‚‰IDã‚’è§£æ±º
      const toppingIds = (localEntry.toppings || [])
        .map((toppingName: string) => {
          // çµµæ–‡å­—ã‚’é™¤å»ã—ã¦åå‰ã ã‘æŠ½å‡º
          const cleanName = toppingName.replace(/^[^\p{L}\p{N}]+/u, '').trim()
          const option = toppingOptions.value.find(
            (opt) =>
              opt.name === cleanName ||
              `${opt.emoji}${opt.name}` === toppingName ||
              opt.name === toppingName
          )
          return option?.id
        })
        .filter(Boolean)

      // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’ä½œæˆ
      const { data: newEntry, error: entryError } = await supabase
        .from('hotdog_entries')
        .insert({
          created_at: localEntry.createdAt,
          completed: localEntry.completed || false,
          completed_at: localEntry.completedAt || null,
        })
        .select()
        .single()

      if (entryError) throw entryError

      // ãƒˆãƒƒãƒ”ãƒ³ã‚°ã‚’é–¢é€£ä»˜ã‘
      if (toppingIds.length > 0) {
        const entryToppings = toppingIds.map((toppingId: string) => ({
          entry_id: newEntry.id,
          topping_id: toppingId,
        }))

        const { error: toppingsError } = await supabase
          .from('entry_toppings')
          .insert(entryToppings)

        if (toppingsError) throw toppingsError
      }
    }

    // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†å¾Œã€LocalStorageã‚’ã‚¯ãƒªã‚¢
    localStorage.removeItem(STORAGE_KEY)
    localStorage.removeItem(OLD_STORAGE_KEY)

    console.log('LocalStorageã‹ã‚‰Supabaseã¸ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†')

    // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’å†å–å¾—
    await fetchEntries()
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼'
    console.error('ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:', e)
  } finally {
    loading.value = false
  }
}

// ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
export function formatDisplayTimestamp(isoTimestamp: string) {
  const parsed = new Date(isoTimestamp)
  if (Number.isNaN(parsed.getTime())) return isoTimestamp
  return parsed.toLocaleString(undefined, {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  })
}

// å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚
export function useHotdogStore() {
  return {
    entries,
    toppingOptions,
    sortedEntries,
    totalHotdogs,
    uniqueToppingsUsed,
    toppingFrequency,
    topToppings,
    hourlySales,
    loading,
    error,
  }
}
